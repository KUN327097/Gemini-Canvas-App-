<!DOCTYPE html>
<!-- saved from url=(0132)blob:https://64hwhetd7coqcnumh0bo8r9s1f0viut1enfyp219w8u48j16fg-h796855997.scf.usercontent.goog/14f1d8c8-7664-483b-8d71-fd6abe52c6ca -->
<html lang="zh-CN" class="scroll-smooth"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6ImY3NWQ2NDhiMmFkZjUwOWU5MTEzMWVlYjQ2MzRlYTBhNGUxOTg3ZDUiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6Ly9pZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIxNTM4MDgxNTc2MDc1ODA4ODYyNSIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiJlMjAyMGY5N2RlMTYtY2FudmFzX3BsYXlib29rX3NwYV8xLTM2NyJ9LCJleHAiOjE3NTYxMDcwMDEsImlhdCI6MTc1NjEwMzQwMSwiYWxnIjoiUlMyNTYifQ.K9HJJ7kI3Mdth5OkIix6_2dG4gXsUfaRTLAoN3ve3Q1-HOBxC1845KipAGwd1IwbOoynCGwR1StUwO2VBHa_9Ci1LC3pjcu8aJgOq20XCfT6L5kae49sZM0UuGebifYh1ISegqCxmast5qyc2tCYbRI0XvrxPLWns5FDGbnHz6195ARCw7QC2LQrzFiuY1JENcU9pJ-RzaoTd_nsNN5BcYgzjd-PBfUZBB_gsKckAy31omCjbGFLK1l1kCeAY4Y7RAlaUT2k3WhrgtTteMy0bYMmcWpsQxQ8S_8HsmNrNL13mprL6C-NS78hlmgfNw4_hs1XaK9bqKOJ45D3r4IBpQ","e2020f97de16-canvas_playbook_spa_1-367")</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash-preview-05-20","imageModelName":"imagen-3.0-generate-002","imageEditModelName":"gemini-2.0-flash-preview-image-generation","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17"]})</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式工作流指南：集成 Canvas、Xano 与 WeWeb</title>
    <script src="https://cdn.tailwindcss.com/"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com/">
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&amp;display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: The SPA is designed as a task-oriented, multi-section dashboard. A sticky top navigation allows users to jump to key thematic areas: 'The Tech Stack' (understanding the tools), 'The Workflow' (exploring the process), 'Implementation' (learning the 'how-to'), and 'Strategic Value' (understanding the 'why'). This non-linear structure prioritizes user exploration over the report's linear format. It allows users to dive into the section most relevant to them, facilitating better understanding and synthesis. Key interactions include clickable flowchart nodes to reveal details and interactive charts to compare tool responsibilities, making the abstract concepts tangible and engaging. -->
    <!-- Visualization & Content Choices: 
        1. Report Info: Tool roles (Canvas, Xano, WeWeb). Goal: Compare. Viz: Interactive bar chart. Interaction: Hover for details. Justification: More engaging than a static table, allows for quick comparison of responsibilities. Library: Chart.js.
        2. Report Info: 4-stage workflow. Goal: Organize/Explain Process. Viz: HTML/CSS flowchart. Interaction: Click a stage to expand a detailed panel. Justification: Visually represents the process flow and allows users to drill down into details without cluttering the main view. Method: Vanilla JS + Tailwind CSS.
        3. Report Info: Three implementation strategies. Goal: Compare/Inform. Viz: Interactive cards. Interaction: Click to reveal details (difficulty, skills, use case). Justification: A modern, clean way to present comparative options. Method: Vanilla JS + Tailwind CSS.
        4. Report Info: "Design-First" vs. "Interaction-First" paradigm. Goal: Compare/Inform. Viz: Donut chart. Interaction: Static visualization with clear labels. Justification: Provides a quick, impactful visual summary of the core strategic shift. Library: Chart.js.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #FDFBF8;
            color: #4A4A4A;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 450px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .nav-link {
            transition: color 0.3s, border-bottom-color 0.3s;
        }
        .nav-link:hover {
            color: #D97706; /* amber-600 */
        }
        .active-link {
            color: #D97706;
            border-bottom-color: #D97706;
        }
        .stage-card {
            transition: all 0.3s ease-in-out;
            border-color: #E5E7EB; /* gray-200 */
        }
        .stage-card.active {
            border-color: #F59E0B; /* amber-500 */
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05);
        }
        .details-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
        }
        .details-panel.open {
            max-height: 1000px;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }
    </style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.absolute{position:absolute}.relative{position:relative}.sticky{position:sticky}.left-0{left:0px}.top-0{top:0px}.top-1\/2{top:50%}.z-50{z-index:50}.mx-auto{margin-left:auto;margin-right:auto}.mb-12{margin-bottom:3rem}.mb-2{margin-bottom:0.5rem}.mb-20{margin-bottom:5rem}.mb-3{margin-bottom:0.75rem}.mb-4{margin-bottom:1rem}.mb-6{margin-bottom:1.5rem}.mr-4{margin-right:1rem}.mt-2{margin-top:0.5rem}.mt-20{margin-top:5rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-0\.5{height:0.125rem}.h-64{height:16rem}.h-8{height:2rem}.w-8{width:2rem}.w-full{width:100%}.max-w-3xl{max-width:48rem}.flex-grow{flex-grow:1}.-translate-y-1\/2{--tw-translate-y:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.scroll-mt-20{scroll-margin-top:5rem}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.gap-8{gap:2rem}.space-x-8 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(2rem * var(--tw-space-x-reverse));margin-left:calc(2rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-6 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.scroll-smooth{scroll-behavior:smooth}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:0.5rem}.border{border-width:1px}.border-2{border-width:2px}.border-b-2{border-bottom-width:2px}.border-t{border-top-width:1px}.border-amber-400{--tw-border-opacity:1;border-color:rgb(251 191 36 / var(--tw-border-opacity, 1))}.border-gray-200{--tw-border-opacity:1;border-color:rgb(229 231 235 / var(--tw-border-opacity, 1))}.border-transparent{border-color:transparent}.bg-amber-100{--tw-bg-opacity:1;background-color:rgb(254 243 199 / var(--tw-bg-opacity, 1))}.bg-gray-300{--tw-bg-opacity:1;background-color:rgb(209 213 219 / var(--tw-bg-opacity, 1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-white\/80{background-color:rgb(255 255 255 / 0.8)}.p-6{padding:1.5rem}.p-8{padding:2rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.py-12{padding-top:3rem;padding-bottom:3rem}.py-4{padding-top:1rem;padding-bottom:1rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.pb-1{padding-bottom:0.25rem}.pt-4{padding-top:1rem}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-amber-700{--tw-text-opacity:1;color:rgb(180 83 9 / var(--tw-text-opacity, 1))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity, 1))}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity, 1))}.text-gray-700{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity, 1))}.text-gray-800{--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity, 1))}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.backdrop-blur-lg{--tw-backdrop-blur:blur(16px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}@media (min-width: 768px){.md\:block{display:block}.md\:flex{display:flex}.md\:h-80{height:20rem}.md\:grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}.md\:grid-cols-3{grid-template-columns:repeat(3, minmax(0, 1fr))}.md\:grid-cols-4{grid-template-columns:repeat(4, minmax(0, 1fr))}.md\:text-5xl{font-size:3rem;line-height:1}}</style></head>
<body class="antialiased">

    <header class="bg-white/80 backdrop-blur-lg sticky top-0 z-50 shadow-sm">
        <nav class="container mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="text-xl font-bold text-gray-800">
                    Canvas-to-Production Playbook
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <a href="blob:https://64hwhetd7coqcnumh0bo8r9s1f0viut1enfyp219w8u48j16fg-h796855997.scf.usercontent.goog/14f1d8c8-7664-483b-8d71-fd6abe52c6ca#tech-stack" class="nav-link text-gray-600 border-b-2 border-transparent pb-1">技术栈</a>
                    <a href="blob:https://64hwhetd7coqcnumh0bo8r9s1f0viut1enfyp219w8u48j16fg-h796855997.scf.usercontent.goog/14f1d8c8-7664-483b-8d71-fd6abe52c6ca#workflow" class="nav-link text-gray-600 border-b-2 border-transparent pb-1">工作流</a>
                    <a href="blob:https://64hwhetd7coqcnumh0bo8r9s1f0viut1enfyp219w8u48j16fg-h796855997.scf.usercontent.goog/14f1d8c8-7664-483b-8d71-fd6abe52c6ca#implementation" class="nav-link text-gray-600 border-b-2 border-transparent pb-1">实施策略</a>
                    <a href="blob:https://64hwhetd7coqcnumh0bo8r9s1f0viut1enfyp219w8u48j16fg-h796855997.scf.usercontent.goog/14f1d8c8-7664-483b-8d71-fd6abe52c6ca#strategy" class="nav-link text-gray-600 border-b-2 border-transparent pb-1">战略价值</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-12">

        <section id="intro" class="text-center mb-20">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-800 mb-4">现代化应用开发的新范式</h1>
            <p class="text-lg text-gray-600 max-w-3xl mx-auto">
                本应用将深入解析一份关于集成 Gemini Canvas、Xano 和 WeWeb 的战略工作流报告。您将通过交互式的方式，理解从 AI 驱动的概念构思到可扩展生产级应用的完整路径，探索如何将开发速度与工程稳健性完美结合。
            </p>
        </section>

        <section id="tech-stack" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4 text-gray-800">解构现代开发技术栈</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">
                成功的应用架构始于明确的角色划分。这个技术栈遵循“关注点分离”原则，每个工具都扮演着不可或缺的独特角色。下方将展示每个工具的核心职责，并通过图表直观比较它们在开发任务中的作用。
            </p>

            <div class="grid md:grid-cols-3 gap-8 mb-12 text-center">
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <div class="text-4xl mb-4">💡</div>
                    <h3 class="text-xl font-semibold mb-2 text-gray-800">Gemini Canvas</h3>
                    <p class="text-gray-600">AI 驱动的构思与原型引擎。负责将自然语言转化为可交互的前端原型，是项目最初 10% 的“概念编译器”。</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <div class="text-4xl mb-4">⚙️</div>
                    <h3 class="text-xl font-semibold mb-2 text-gray-800">Xano</h3>
                    <p class="text-gray-600">可扩展的无代码后端基础。作为应用的“大脑”，负责数据存储、业务逻辑和 API 生成。</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <div class="text-4xl mb-4">🎨</div>
                    <h3 class="text-xl font-semibold mb-2 text-gray-800">WeWeb</h3>
                    <p class="text-gray-600">专业的用户体验与前端层。用于构建像素级精确的生产级用户界面，并与后端数据连接。</p>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-lg">
                <h3 class="text-2xl font-bold text-center mb-6 text-gray-800">工具角色与职责矩阵</h3>
                <div class="chart-container">
                    <canvas id="rolesChart" width="1000" height="500" style="display: block; box-sizing: border-box; height: 400px; width: 800px;"></canvas>
                </div>
            </div>
        </section>

        <section id="workflow" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4 text-gray-800">“Canvas-to-Production” 工作流</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">
                从原型到生产的“过渡”并非简单的文件迁移，而是一个严谨的、分阶段的战略过程。点击下方流程图中的任意阶段，即可展开查看该阶段的核心任务与交付物。这个结构化的方法确保了从快速验证到稳健交付的平滑演进。
            </p>
            <div class="relative">
                <div class="hidden md:block absolute top-1/2 left-0 w-full h-0.5 bg-gray-300 -translate-y-1/2"></div>
                <div class="grid md:grid-cols-4 gap-8 relative">
                    <div class="stage-card bg-white p-6 rounded-lg shadow-md border-2 cursor-pointer" data-stage="1">
                        <div class="flex items-center mb-4">
                            <span class="bg-amber-100 text-amber-700 rounded-full h-8 w-8 flex items-center justify-center font-bold mr-4">1</span>
                            <h3 class="text-lg font-semibold text-gray-800">概念化与原型</h3>
                        </div>
                        <p class="text-sm text-gray-600">在 Canvas 中使用 AI 快速验证核心概念，生成交互式原型。</p>
                    </div>
                    <div class="stage-card bg-white p-6 rounded-lg shadow-md border-2 cursor-pointer" data-stage="2">
                        <div class="flex items-center mb-4">
                            <span class="bg-amber-100 text-amber-700 rounded-full h-8 w-8 flex items-center justify-center font-bold mr-4">2</span>
                            <h3 class="text-lg font-semibold text-gray-800">解构与抽象</h3>
                        </div>
                        <p class="text-sm text-gray-600">分析原型，提取数据模型、业务逻辑和 UI 组件三大架构蓝图。</p>
                    </div>
                    <div class="stage-card bg-white p-6 rounded-lg shadow-md border-2 cursor-pointer" data-stage="3">
                        <div class="flex items-center mb-4">
                            <span class="bg-amber-100 text-amber-700 rounded-full h-8 w-8 flex items-center justify-center font-bold mr-4">3</span>
                            <h3 class="text-lg font-semibold text-gray-800">后端搭建</h3>
                        </div>
                        <p class="text-sm text-gray-600">在 Xano 中实现数据模型和业务逻辑，构建可靠的后端 API。</p>
                    </div>
                    <div class="stage-card bg-white p-6 rounded-lg shadow-md border-2 cursor-pointer" data-stage="4">
                        <div class="flex items-center mb-4">
                            <span class="bg-amber-100 text-amber-700 rounded-full h-8 w-8 flex items-center justify-center font-bold mr-4">4</span>
                            <h3 class="text-lg font-semibold text-gray-800">前端重构</h3>
                        </div>
                        <p class="text-sm text-gray-600">在 WeWeb 中重构 UI，并与 Xano 的实时后端进行数据集成。</p>
                    </div>
                </div>
            </div>
            <div id="stage-details-container" class="mt-8"></div>
        </section>

        <section id="implementation" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4 text-gray-800">实施策略：从 Canvas 到 WeWeb</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">
                将 Canvas (React/HTML) 的资产应用到 WeWeb (Vue.js) 环境中需要灵活的策略。由于技术栈不同，直接复制粘贴不可行。以下是三种核心策略，您可以根据组件的复杂度和团队的技术能力进行选择。
            </p>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200 flex flex-col">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">策略 A: 视觉参考与手动重构</h3>
                    <p class="text-gray-600 flex-grow">将 Canvas 预览作为视觉蓝图，在 WeWeb 中使用其原生编辑器重新构建组件。这是最高效、最简单的方法。</p>
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <p class="text-sm text-gray-500"><b class="text-gray-700">难度:</b> 低</p>
                        <p class="text-sm text-gray-500"><b class="text-gray-700">适用:</b> 标准 UI 组件（按钮、表单等）。</p>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200 flex flex-col">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">策略 B: 逻辑与代码片段提取</h3>
                    <p class="text-gray-600 flex-grow">从 Canvas 代码中提取有价值的 JS 函数或 CSS 样式，并将其嵌入 WeWeb 的自定义代码区域。</p>
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <p class="text-sm text-gray-500"><b class="text-gray-700">难度:</b> 中</p>
                        <p class="text-sm text-gray-500"><b class="text-gray-700">适用:</b> 复杂动画、特定数据处理逻辑。</p>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-lg border border-gray-200 flex flex-col">
                    <h3 class="text-xl font-semibold mb-3 text-gray-800">策略 C: 自定义组件适配 (高级)</h3>
                    <p class="text-gray-600 flex-grow">手动将 Canvas 生成的 React/HTML 代码翻译成一个独立的 Vue.js 组件，然后导入 WeWeb 使用。</p>
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <p class="text-sm text-gray-500"><b class="text-gray-700">难度:</b> 高</p>
                        <p class="text-sm text-gray-500"><b class="text-gray-700">适用:</b> 高度定制的交互式组件（图表、游戏）。</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="strategy" class="scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4 text-gray-800">战略价值：范式的转变</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">
                此工作流代表了从传统的“设计先行”到创新的“交互先行”的范式转变。与 Figma 等静态设计工具相比，Canvas 能够从一开始就生成可交互、带逻辑的原型，让团队更早地验证核心用户体验，从而在战略上获得巨大优势。
            </p>
            <div class="grid md:grid-cols-2 gap-8 items-center">
                <div class="bg-white p-8 rounded-lg shadow-lg">
                    <h3 class="text-2xl font-bold text-center mb-6 text-gray-800">范式转变：关注点迁移</h3>
                    <div class="chart-container h-64 md:h-80">
                        <canvas id="paradigmChart" width="670" height="400" style="display: block; box-sizing: border-box; height: 320px; width: 536px;"></canvas>
                    </div>
                </div>
                <div class="space-y-6">
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h4 class="font-semibold text-lg text-gray-800">传统路径: 设计先行 (Figma-to-WeWeb)</h4>
                        <p class="text-gray-600 mt-2">从像素级精确的静态视觉设计稿开始，重点在于“它看起来是什么样”。交互和功能在开发后期才被验证。</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md border-2 border-amber-400">
                        <h4 class="font-semibold text-lg text-gray-800">新路径: 交互先行 (Canvas-to-WeWeb)</h4>
                        <p class="text-gray-600 mt-2">从定义交互和功能的自然语言提示开始，重点在于“它能做什么”。视觉设计是功能需求的结果，核心用户体验在项目极早期就得到验证。</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-white mt-20 border-t">
        <div class="container mx-auto px-6 py-6 text-center text-gray-500">
            <p>© 2025 交互式工作流指南。基于 "Canvas-to-Production Playbook" 报告生成。</p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const stageDetailsData = {
                '1': {
                    title: '阶段 1: 概念化与快速原型设计',
                    content: `
                        <h4 class="font-semibold text-lg mb-2 text-gray-800">核心流程:</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li><b>自然语言驱动生成:</b> 通过描述性提示启动项目，快速生成界面和功能。</li>
                            <li><b>迭代式实时优化:</b> 与 Canvas 进行“对话式”开发，实时调整 UI、逻辑和样式。</li>
                            <li><b>模拟数据结构:</b> 有意识地引导 AI 生成暗示特定数据模型的代码，为后端设计提供参考。</li>
                        </ul>
                        <h4 class="font-semibold text-lg mt-4 mb-2 text-gray-800">交付物:</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li>一个功能性的、可交互的 Canvas 原型。</li>
                            <li>一系列由 AI 生成的前端代码片段（HTML, React, CSS, JS）。</li>
                        </ul>
                    `
                },
                '2': {
                    title: '阶段 2: 解构与抽象 (关键桥梁)',
                    content: `
                        <h4 class="font-semibold text-lg mb-2 text-gray-800">核心流程:</h4>
                        <p class="text-gray-600 mb-4">这是最具战略意义的步骤。在编写生产代码前，深入分析原型，并提取三大核心架构蓝图，将开发从“复制粘贴”提升到“架构设计”的高度。</p>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li><b>蓝图 1 (数据模型):</b> 定义数据实体、属性及关系。</li>
                            <li><b>蓝图 2 (业务逻辑与 API):</b> 记录用户操作，转化为后端 API 端点需求。</li>
                            <li><b>蓝图 3 (UI 组件库):</b> 盘点所有可复用的 UI 元素，形成组件清单。</li>
                        </ul>
                    `
                },
                '3': {
                    title: '阶段 3: 在 Xano 中进行后端搭建',
                    content: `
                        <h4 class="font-semibold text-lg mb-2 text-gray-800">核心流程:</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li><b>数据库构建:</b> 根据数据模型蓝图，使用可视化工具创建数据库表和关系。</li>
                            <li><b>API 生成与定制:</b> 利用无代码 API 构建器创建业务逻辑蓝图中定义的端点。</li>
                            <li><b>业务逻辑实现:</b> 使用函数堆栈（Function Stack）以可视化方式构建复杂业务逻辑。</li>
                        </ul>
                        <h4 class="font-semibold text-lg mt-4 mb-2 text-gray-800">交付物:</h4>
                        <p class="text-gray-600">一套功能完整、文档齐全的 RESTful API 端点。</p>
                    `
                },
                '4': {
                    title: '阶段 4: 在 WeWeb 中进行前端重构与集成',
                    content: `
                        <h4 class="font-semibold text-lg mb-2 text-gray-800">核心流程:</h4>
                        <ul class="list-disc list-inside space-y-2 text-gray-600">
                            <li><b>组件构建:</b> 根据 UI 组件库蓝图，在 WeWeb 中重构各个组件。</li>
                            <li><b>数据源配置:</b> 添加 Xano 作为数据源，连接到已创建的 API 端点。</li>
                            <li><b>数据绑定与工作流设置:</b> 将 UI 元素与来自 Xano 的数据进行绑定，并配置交互行为以触发 API 调用。</li>
                        </ul>
                        <h4 class="font-semibold text-lg mt-4 mb-2 text-gray-800">交付物:</h4>
                        <p class="text-gray-600">一个可用于生产的、可扩展的 Web 应用程序。</p>
                    `
                }
            };

            const stageCards = document.querySelectorAll('.stage-card');
            const detailsContainer = document.getElementById('stage-details-container');
            let activeStage = null;

            stageCards.forEach(card => {
                card.addEventListener('click', () => {
                    const stage = card.dataset.stage;
                    
                    if (activeStage === stage) {
                        detailsContainer.innerHTML = '';
                        card.classList.remove('active');
                        activeStage = null;
                        return;
                    }

                    stageCards.forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    activeStage = stage;

                    const details = stageDetailsData[stage];
                    const panel = document.createElement('div');
                    panel.className = 'details-panel bg-white p-6 rounded-lg shadow-inner border border-gray-200';
                    panel.innerHTML = details.content;
                    
                    detailsContainer.innerHTML = '';
                    detailsContainer.appendChild(panel);
                    
                    setTimeout(() => {
                        panel.classList.add('open');
                    }, 10);
                });
            });

            const rolesCtx = document.getElementById('rolesChart').getContext('2d');
            new Chart(rolesCtx, {
                type: 'bar',
                data: {
                    labels: ['UI/UX 构思', '交互原型', '数据库', '业务逻辑/API', '最终前端 UI', '托管部署'],
                    datasets: [{
                        label: 'Canvas (主要)',
                        data: [2, 2, 0, 0, 0, 0],
                        backgroundColor: 'rgba(251, 191, 36, 0.6)',
                        borderColor: 'rgba(251, 191, 36, 1)',
                        borderWidth: 1
                    }, {
                        label: 'Canvas (辅助)',
                        data: [0, 0, 0, 0, 1, 1],
                        backgroundColor: 'rgba(251, 191, 36, 0.3)',
                        borderColor: 'rgba(251, 191, 36, 1)',
                        borderWidth: 1
                    }, {
                        label: 'Xano (主要)',
                        data: [0, 0, 2, 2, 0, 1],
                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1
                    }, {
                        label: 'WeWeb (主要)',
                        data: [0, 0, 0, 0, 2, 1],
                        backgroundColor: 'rgba(16, 185, 129, 0.6)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1
                    }, {
                        label: 'WeWeb (辅助)',
                        data: [1, 1, 0, 0, 0, 0],
                        backgroundColor: 'rgba(16, 185, 129, 0.3)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                        },
                        y: {
                            stacked: true,
                            ticks: {
                                callback: function(value) {
                                    if (value === 1) return '辅助';
                                    if (value === 2) return '主要';
                                    return '';
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ' + (context.raw === 2 ? '主要职责' : '辅助职责');
                                    }
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: '数值 2 代表“主要职责”，1 代表“辅助职责”'
                        }
                    }
                }
            });

            const paradigmCtx = document.getElementById('paradigmChart').getContext('2d');
            new Chart(paradigmCtx, {
                type: 'doughnut',
                data: {
                    labels: ['设计先行 (传统)', '交互先行 (新范式)'],
                    datasets: [{
                        label: '开发范式',
                        data: [40, 60],
                        backgroundColor: [
                            'rgba(107, 114, 128, 0.6)',
                            'rgba(245, 158, 11, 0.7)',
                        ],
                        borderColor: [
                            'rgba(107, 114, 128, 1)',
                            'rgba(245, 158, 11, 1)',
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.label + ': ' + context.raw + '% 关注度';
                                }
                            }
                        }
                    }
                }
            });

            const sections = document.querySelectorAll('section[id]');
            const navLinks = document.querySelectorAll('.nav-link');
            
            window.addEventListener('scroll', () => {
                let current = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (pageYOffset >= sectionTop - 80) {
                        current = section.getAttribute('id');
                    }
                });

                navLinks.forEach(link => {
                    link.classList.remove('active-link');
                    if (link.getAttribute('href').includes(current)) {
                        link.classList.add('active-link');
                    }
                });
            });
        });
    </script>


</body></html>